[#3] Dla problemu komiwojażera algorytm pozwalający wyznaczyć rozwiązanie optymalne:; istnieje i ma złożoność wielomianową; istnieje i ma złożoność wykładniczą; nie istnieje; istnieje tylko dla niektórych przypadków problemu komiwojażera; B; 
[#10] Lista rozkazów procesora:; w skład listy rozkazów zawsze wchodzi mnożenie; w procesorze wykonywanym przy użyciu FPGA musi być zgodna z listą rozkazów przewidzianą przez producenta układu FPGA; musi zawierać rozkazy z różnymi trybami adresowania; projektowana jest w zależności od potrzeb związanych z zastosowaniem procesora; D; 
[#12] Licznik rozkazów:; jest to licznik z wejściem równoległym wykorzystywanym wyłącznie przy skokach bezwarunkowych; służy do pamiętania adresu mającego się wykonać rozkazu lub adresu aktualnie pobieranego argumentu z pamięci programu; jest wykorzystywany do zliczania liczby wykonanych instrukcji; przechowuje informacje o aktualnie wykonywanym procesie; B; 
[#13] Rozkaz skoku bezwarunkowego procesora:; powoduje wpisanie do licznika rozkazów adresu rozkazu mającego się wykonać po skoku niezależnie od warunku; powoduje wpisanie do licznika rozkazów adresu rozkazu mającego się wykonać po skoku, ale tylko w przypadku spełnienia warunku skoku; nie wpływa na stan licznika rozkazów procesora; zmienia wartość rejestru flagowego procesora; A; 
[#14] Rozkaz skoku warunkowego procesora:; nie wpływa na stan licznika rozkazów procesora; powoduje wpisanie do licznika rozkazów adresu rozkazu mającego się wykonać po skoku niezależnie od warunku; powoduje wpisanie do licznika rozkazów adresu rozkazu mającego się wykonać po skoku, ale tylko w przypadku spełnienia warunku skoku; żadne z pozostałych; C; 
[#15] Rozkaz procesora wykonujący dodanie dwóch liczb:; powoduje dodanie dwóch liczb, wynik zapisuje do licznika rozkazów; wykorzystuje ALU; żadne z pozostałych; automatycznie aktualizuje wskaźnik stosu; B; 
[#34] Wskaż, w których przypadkach klauzule instrukcji SELECT są ułożone we właściwej kolejności:; from, where, group by, having, order by; from, group by, having, where, order by; from, group by, where, having, order by; from, order by, group by, having, where; A; 
[#36] Dana jest relacja R o schemacie H = {A, B, C, D, E} oraz zbiór zależności funkcyjnych F = {{B, C} -> {D, E}, {C, D} -> {B, E}, {D} -> {C}, {E} -> {B}}. W jakiej maksymalnie postaci normalnej jest relacja R? Zakładamy, że jest w 1NF.; 1NF; 2NF; 3NF; 4NF; C; 
[#41] Które wyrażenie SQL zwraca wszystkie wiersze tabeli "Osoby" posortowane malejąco według atrybutu "Imie"?; SELECT * FROM Osoby SORT BY 'Imie' DESC; SELECT * FROM Osoby ORDER BY Imie DESC; SELECT * FROM Osoby SORT 'Imie' DESC; SELECT * FROM Osoby ORDER Imie DESC; B; 
[#42] Jak możesz zmienić wartość "Kowalski" na "Nowak" w atrybucie "Nazwisko" w tabeli "Osoby"?; MODIFY Osoby SET Nazwisko='Nowak' WHERE Nazwisko='Kowalski'; MODIFY Osoby SET Nazwisko='Kowalski' INTO Nazwisko='Nowak'; UPDATE Osoby SET Nazwisko='Kowalski' INTO Nazwisko='Nowak'; UPDATE Osoby SET Nazwisko='Nowak' WHERE Nazwisko='Kowalski'; D; 
[#43] Jak można przy pomocy SQL uzyskać informację o liczbie wierszy w tabeli "Osoby"?; SELECT COUNT(*) FROM Osoby; SELECT COUNT() FROM Osoby; SELECT COLUMNS() FROM Osoby; SELECT COLUMNS(*) FROM Osoby; A; 
[#44] Jako można przy pomocy SQL wybrać wszystkie wiersze z tabeli "Osoby", w których wartość atrybutu "Imie" zaczyna się od "a"?; SELECT * FROM Osoby WHERE Imie LIKE '%a'; SELECT * FROM Osoby WHERE Imie='%a%'; SELECT * FROM Osoby WHERE Imie LIKE 'a%'; SELECT * FROM Osoby WHERE Imie='a'; C; 
[#48] Z jakim problemem trzeba się uporać przy odwzorowaniu w schemacie relacyjnej bazy danych relacji typu n:m (wiele do wiele)?; zdefiniować podwójne indeksowanie plików odpowiadających każdej z tabel; trzeba zaprojektować dodatkową tabelę; dobrać odpowiedni klucz obcy w drugiej z tabel; trzeba użyć dodatkowo widoku (view); B; 
[#54] Jakie są główne aktywności w modelu spiralnym?; Planowanie, Analiza Ryzyka, Konstrukcja, Walidacja; Szybki Projekt, Budowa Prototypu, Ocena Prototypu, Redefinicja Prototypu; Analiza Wymagań, Projektowanie, Kodowanie, Testowanie; Definiowanie, Prototypowanie, Testowanie, Dostarczenie Produktu; A; 
[#55] Jakiego widoku nie znajdziesz w modelu architektonicznym Kruchtena?; przypadków użycia; konstrukcji; logicznego; przepływu danych; D; 
[#56] Jaką rolę na diagramach klas UML pełni kompozycja?; jest związkiem typu gen-spec między instancjami klasy; jest związkiem typu część-całość między obiektami; wspomaga graficzne rozlokowanie symboli klas na diagramie; oznacza ukrywanie złożoności obiektów przed użytkownikiem; B; 
[#59] Tworzenie modelu obiektowego z istniejącej relacyjnej bazy danych jest określane jako:; forward engineering; backward engineering; reverse engineering; inverse engineering; C; 
[#61] Które z poniższych stwierdzeń nie jest celem budowy modeli analitycznych:; opracowanie rozwiązań problemów; ustalenie wszystkich czynników / warunków w dziedzinie przedmiotowej / w otoczeniu projektu, które mogą wpłynąć na decyzje projektowe; stworzenie logicznego modelu systemu, opisującego sposób realizacji wymagań, ale bez szczegółów implementacyjnych; automatyzacja procesu wdrażania systemu; A; 
[#62] Wstępna próba zdefiniowania elementów systemu oraz ich wzajemnych relacji, organizowanie tych elementów w dobrze określone warstwy z wyraźnie nakreślonymi zależnościami nazywa się analizą:; przypadków użycia; architektoniczną; strukturalną; systemową; B; 
[#63] Którego z poniższych narzędzi nie używa się podczas analizy systemowej?; Data Flow Diagram; Decision Tree; Object Modelling Technique; HOOD; B; 
[#64] Które z podanych rodzajów wymagań nie są określane podczas przygotowywania definicji wymagań systemowych?; abstrakcyjne wymagania funkcjonalne; szczegółowe wymagania funkcjonalne; cechy lub zachowania, których system nie powinien przejawiać; właściwości systemu; B; 
[#71] Jakie aspekty powinien uwzględniać pełny model systemu w podejściu strukturalnym do analizy i projektowania?; aspekt funkcjonalny, aspekt danych i ich powiązań; aspekt funkcjonalny i aspekt dynamiki systemu; aspekt danych i ich powiązań, aspekt dynamiki systemu; aspekt funkcjonalny, aspekt danych i ich powiązań, oraz dynamiki systemu; D; 
[#72] Aspekt funkcjonalny systemu informatycznego modelowany jest w podejściu strukturalnym przy pomocy:; Data Flow Diagrams; Entity Relationship Diagrams; State Transition Diagrams; Structure Charts; A; 
[#73] Które z wymienionych podziałów wymagań niefunkcjonalnych są wyczerpujące i rozłączne?; produktowe, organizacyjne, prawne; produktowe, prawne, parametryczne; produktowe, zewnętrzne, strategiczne; produktowe, organizacyjne, zewnętrzne; D; 
[#74] Wymień elementy modelu środowiskowego w strukturalnym podejściu do analizy i projektowania systemów informatycznych:; ERD, DFD, STD; diagram kontekstowy, słownik danych, specyfikacja funkcji; opis celu systemu, wymagania funkcjonalne, wymagania niefunkcjonalne; opis celu systemu, lista zdarzeń, diagram kontekstowy; D; 
[#75] Jaki zestaw diagramów jest używany w metodyce strukturalnej analizy i projektowania systemów informatycznych do pokazania wszystkich aspektów modelowanego systemu?; DFD, ERD i STC; DFD i ERD; DFD, ERD i STD (lub ELH); DFD i STD; C; 
[#76] Które obiekty graficzne są używane do tworzenia diagramu kontekstowego w metodyce strukturalnej analizy i projektowania systemów informatycznych:; proces, przepływ danych (data flow), magazyn danych (data store); proces, obiekt zewnętrzny (external entity), magazyn danych (data store); przepływ danych (data flow), obiekt zewnętrzny (external entity), magazyn danych; proces, przepływ danych (data flow), obiekt zewnętrzny (external entity); D; 
[#78] Wskaż ten element dokumentacji projektowej, który zawiera zapis w postaci pseudokodu (metodyka strukturalna analizy i projektowania systemów informatycznych):; opis wymagań niefunkcjonalnych; opis wymagań funkcjonalnych; specyfikacja funkcji; opis celu przedsięwzięcia projektowego; C; 
[#79] Który element DFD w metodyce strukturalnej stanowi podstawę konstruowania ERD (Entity Relationship Diagram) - diagramu związków encji:; przepływ danych (data flow); diagram kontekstowy (context diagram); obiekt zewnętrzny (external entity); magazyn danych (data store); D; 
[#80] Jaki typ danych w Haskellu będzie miało następujące wyrażenie: r x = x:r x; r :: [a]; r :: Integer a => a -> [a]; r :: a -> [a]; r :: a -> a -> [a]; C; 
[#82] Haskell jest językiem opartym o paradygmat:; funkcyjny; strukturalny; imperatywny; obiektowy; A; 
[#86] Aby sprawdzić, czy dwa obiekty typu String w języku Java mają taką samą zawartość, można:; użyć metody equals(); ==; porównać ich długość za pomocą length(); użyć operatora compareTo(); A; 
[#90] W jaki sposób usuwane są obiekty w języku Java?; usuwa się je przez przekazanie referencji do usuwanego obiektu do metody System.gc(); nie są programowo usuwane, to środowisko wykonawcze podejmuje decyzje czy i kiedy je usunąć; usuwane są natychmiast po wyjściu z zakresu; wymagają jawnego zwolnienia za pomocą free(); B; 
[#91] Które z poniższych stwierdzeń odnoszące się do klas wewnętrznych i zagnieżdżonych w języku Java są prawdziwe?; w metodach klasy zagnieżdżonej (zadeklarowanej z modyfikatorem static) jest dostępna referencja Outer.this, gdzie Outer jest nazwą klasy zewnętrznej; obiekt klasy wewnętrznej ma swój stan niezależny od innych obiektów powiązanych z obiektem klasy zewnętrznej; klasy wewnętrzne muszą dziedziczyć po otaczających je klasach zewnętrznych; klasa wewnętrzna (zadeklarowana bez modyfikatora static) nie ma dostępu do prywatnych zmiennych klasy zewnętrznej; B; 
[#95] Co możesz powiedzieć o poniższej deklaracji w języku C? int t[10] = {1, 2, [4]=1};; zgodnie ze standardem C99 spowoduje ona utworzenie tablicy zawierającej 10 elementów, z których 7 ma wartość 0; da ona taki sam efekt, jak deklaracja: int t[] = {1, 2, 0, 0, 1}; jest błędna składniowo; inicjalizuje wszystkie elementy tablicy wartością 1; A; 
[#96] W jaki sposób obliczyć długość tablicy w funkcji foo() w języku C? void foo(double f[]) { // dlugosc tablicy t? }; nie da się obliczyć; po wykonaniu poniższej instrukcji długość tablicy będzie umieszczona w zmiennej len: int len; for(len=0; t[len]; len++); użyć funkcji sizeof(f)/sizeof(double); przekazać długość jako dodatkowy parametr funkcji; A; 
[#98] Przeanalizuj poniższą deklarację w języku C: int (x)(int, int);; zmienna x jest dwuwymiarową tablicą wskaźników typu int o zmiennym rozmiarze; deklaracja jest niezgodna ze składnią języka; zmienna x jest wskaźnikiem na funkcję przyjmującą dwa argumenty typu int, zwracającą wartość typu int; zmienna x jest funkcją zwracającą wskaźnik na int; C; 
[#99] Które stwierdzenia dotyczące operatorów w języku C/C++ są poprawne:; operatory addytywne mają mniejszy priorytet niż multiplikatywne; wyrażenie z == ++z jest zawsze fałszywe dla zmiennej z typu int; żadne z pozostałych; operatory bitowe mają wyższy priorytet niż logiczne; A; 
[#100] Dzięki konwencji wywołania funkcji w języku C/C++ znanej jako __cdecl możliwa jest implementacja funkcji o zmiennej liczbie argumentów, jak printf(). Które stwierdzenia charakteryzujące funkcje typu __cdecl są prawdziwe?; w wygenerowanym kodzie wywołania funkcji argumenty umieszczane są na stosie od końca, dzięki temu na szczycie stosu jest jej pierwszy argument i analizując jego zawartość można określić spodziewaną liczbę argumentów wywołania; w języku C kompilator może utworzyć kod wywołania funkcji typu __cdecl nie mając żadnych informacji o typach jej parametrów; funkcje __cdecl są szybsze od __stdcall; argumenty są przekazywane wyłącznie przez rejestry; A; 
[#105] Dla tych samych danych eksperymentalnych podanych poniżej wyznaczono 3 funkcje aproksymujące.; a_1 = a_2 = a_3, b_1 = b_2 = b_3; a_1 = a_2 = a_3, b_1 != b_2 != b_3; a_1 != a_2 != a_3, b_1 = b_2 = b_3; wszystkie współczynniki są różne; B; 
[#106] Rozważmy funkcję kwadratową n zmiennych:; metoda Newtona gwarantuje znalezienie minimum funkcji f w pierwszym kroku; metoda najszybszego spadku gwarantuje znalezienie minimum funkcji f w pierwszym kroku; metoda simpleksu Neldera-Meada gwarantuje znalezienie minimum funkcji f w pierwszym kroku; wszystkie metody wymagają wielu iteracji; A; 
[#107] Czy obliczanie parametrów (współczynników) funkcji aproksymującej można sprowadzić do rozwiązywania układu równań?; tak, ale wtedy i tylko wtedy, gdy funkcja aproksymująca jest funkcją liniową względem zmiennej niezależnej; tak, ale wtedy i tylko wtedy, gdy funkcja aproksymująca jest wielomianem (zmiennej niezależnej); nie można; tylko dla aproksymacji nieliniowej; B; 
[#109] Warunkiem koniecznym i wystarczającym zbieżności metod iteracyjnych prostych (takich jak metoda Jacobiego czy metoda Gaussa-Seidla) rozwiązywania układów równań liniowych jest:; promień spektralny macierzy iterowanej w danej metodzie jest zawsze mniejszy od 1; promień spektralny macierzy iterowanej w danej metodzie jest zawsze większy od 1; macierz układu musi być diagonalnie dominująca; macierz musi być symetryczna; A; 
[#113] Wskaż zdania prawdziwe dotyczące zagadnienia interpolacji wielomianowej z wykorzystaniem jednomianów (tzw. bazy naturalnej):; jest to zadanie dobrze uwarunkowane; ma zdecydowanie lepsze właściwości numeryczne niż metoda Lagrange'a; jest to zadanie źle uwarunkowane; wymaga mniej obliczeń niż inne metody; C; 
[#114] Błędy związane z ograniczeniem nieskończonego ciągu wymaganych obliczeń do skończonej liczby działań nazywamy:; błędami zaokrągleń (ang. rounding errors); błędami niedomiaru (ang. underflow errors); błędami obcięcia (ang. truncation errors); błędami nadmiaru (ang. overflow errors); C; 
[#115] Jeśli niewielkie względne zaburzenia danych wejściowych powodują niewielkie względne zmiany wyników, to wówczas:; współczynnik uwarunkowania osiąga wysoką wartość; współczynnik uwarunkowania osiąga niską wartość; problem jest niestabilny numerycznie; wyniki są zawsze niedokładne; B; 
[#117] Stosując algorytm stycznych poszukiwania jednokrotnego miejsca zerowego funkcji f(x) w przedziale domkniętym [a, b] w dostatecznej bliskości pierwiastka uzyskujemy zbieżność:; kwadratową; wykładniczą; liniową; logarytmiczną; A; 
[#119] Efekt Rungego jest charakterystyczny dla następujących metod interpolacji:; interpolacji funkcjami sklejanymi 1 stopnia dla węzłów równoodległych; interpolacji funkcjami sklejanymi 3 stopnia dla węzłów równoodległych; interpolacji metodą Lagrange'a (wielomianowej) dla węzłów równoodległych; interpolacji metodą Lagrange'a dla węzłów będących zerami wielomianów Czebyszewa; C; 
[#122] Dokładność reprezentacji zmiennoprzecinkowej jest określona przez:; liczbę bitów mantysy; liczbę bitów mantysy i wykładnika; zakres wykładnika; liczbę bitów mantysy i zakres wykładnika; A; 
[#123] Efekt Rungego w interpolacji wielomianowej to:; wynik wyboru złej funkcji interpolującej; wynik braku jednoznaczności rozwiązania zadania interpolacji; konsekwencja arytmetyki zmiennoprzecinkowej; wynik błędu metody; D; 
[#125] Wybierz poprawną odpowiedź:; interpolacja z węzłami będącymi zerami wielomianu Czebyszewa odpowiedniego stopnia eliminuje efekt Rungego; przybliżenia Pade to technika aproksymacji średniokwadratowej; funkcje sklejane nie mogą być wykorzystane do aproksymacji średniokwadratowej ze względu na postać minimalizowanej normy; aproksymacja średniokwadratowa polega na minimalizacji normy Czebyszewa; A; 
[#128] Metody dekompozycji LU:; mają znacznie lepsze własności numeryczne niż metoda eliminacji Gaussa; należą do rodziny metod iteracyjnych niestacjonarnych; nie wymagają wyszukiwania elementu wiodącego; mają lepszą złożoność obliczeniową niż metoda Gaussa, gdyż nie wymagają wyszukiwania elementu wiodącego; A; 
[#129] Wybierz poprawne zdania opisujące metody minimalizacji:; wzór Davidona-Fletchera-Powella jest podstawą metody zmiennej metryki; metoda sprzężonych kierunków jest przykładem ogólnej metody poszukiwania minimum globalnego; metoda największego spadku jest przykładem metody poszukiwania minimum globalnego; metoda simpleksów należy do metod gradientowych; A; 
[#130] Szybka transformata Fouriera:; jest możliwa tylko wtedy, gdy liczba punktów jest całkowitą potęgą 2; ma złożoność obliczeniową ^^O(n)^^, gdzie ^^n^^ - liczba węzłów; jest realizacją wzoru całkowego Fouriera na architekturach równoległych; polega na zamianie pojedynczej transformaty Fouriera na sumę transformat Fouriera; D; 
[#131] Podejście wariacyjne do rozwiązywania równań różniczkowych:; nie nadaje się do obliczeń numerycznych; polega na tym, że szukamy funkcji minimalizującej odpowiedni funkcjonał; polega na wprowadzeniu specjalnej siatki całkowania; polega na uzmiennieniu położeń części punktów siatki; B; 
[#140] Które warstwy modelu OSI/ISO są różne dla sieci WAN i LAN?; fizyczna i łącza danych; fizyczna i sieci; łącza danych i sieci; fizyczna, łącza danych i sieci; A; 
[#141] Dopisz, do czego jest wykorzystywany protokół ARP:; uzyskiwania adresu IP; uzyskiwania adresu MAC urządzenia spoza naszej sieci lokalnej; określenie odwzorowania między adresami warstwy 3 i 2 modelu OSI/ISO; wyznaczania ścieżki pakietu; C; 
[#142] Jeżeli dwie stacje znajdujące się w innych sieciach IP połączone są ze sobą dokładnie jednym routerem i chcą komunikować się ze sobą, to:; obydwie stacje muszą posiadać jednakową maskę; musi być uruchomiony mechanizm Proxy ARP na routerze; na routerze konieczne jest dodanie pozycji routingu statycznego; wymagane jest ustawienie na każdej stacji adresu IP; D; 
[#145] Jaki mechanizm uniemożliwia nieskończone krążenie ramek IP w sieci w przypadku wystąpienia pętli?; mechanizm split-horizon; mechanizm trigger-update; pole TTL; NAT; C; 
[#148] Adres typu broadcast (rozgłoszenia) IP w wersji 4, w której znajduje się host 110.104.1.10 i którą określa maska 255.0.0.0, to:; 110.104.1.10; 110.255.255.255; 110.104.1.255; 110.0.0.0; B; 
[#149] Pole o nazwie Time To Live w datagramie IP, które zabezpiecza przed zapętleniem routowania datagramu pomiędzy kolejnymi routerami w sieci, zawiera:; liczbę routerów, przez jakie datagram IP może zostać przekazany danej; czas w sekundach, w którym datagram IP można jeszcze przekazywać dalej; liczbę pakietów, które mogą być przesłane; unikalny identyfikator datagramu; A; 
[#150] Protokół UDP definiuje identyfikatory przesyłanych do hosta-odbiorcy datagramów zwane numerami portów, o długości:; 8 bitów; 32 bity; 4 bity; 16 bitów; D; 
[#151] Wartości adresu IPv6 oraz maski, określające wszystkie hosty w internecie, to:; ::/0; 0.0.0.0/0; ::/2000; ff02::1; A; 
[#152] Istnienie zasady “Longest prefix match” w rutowaniu IP spowoduje, że adres docelowy 200.200.200.1 datagramu IP przy istnieniu w tablicy rutowania jednocześnie reguł o wzorcach i maskach (podano w notacji CIDR): 200.200.200.0/18, 200.200.200.0/20, 200.200.200.0/22, 200.200.200.0/24 zostanie dopasowany do:; 200.200.200.0/20; 200.200.200.0/18; 200.200.200.0/22; 200.200.200.0/24; D; 
[#153] Maksymalna długość pakietu IP wersja 4, licząc w bajtach, to:; 1500; 65535; 576; 1025; B; 
[#154] Router iBGP (internal Border Gateway Protocol), którego wprowadzenie do systemu rutowania iBGP umożliwia znaczne zredukowanie ilości otwartych sesji BGP między innymi routerami (rezygnację z tzw. full-mesh) nosi nazwę:; BGP Mirror; Route Reflector Client (RRC); BGP Hub; Router Aggregator; B; 
[#155] Liczba klas CoS (Class of Service), definiowanych przez podstawowy mechanizm implementacji QoS (Quality of Service) w Ethernet (czyli standard IEEE 802.1p), to:; 8; 255; 16; 7; A; 
[#156] Wariant protokołu STP (Spanning Tree Protocol, IEEE 802.1d) pozwalający w technologii Ethernet na logiczne pogrupowanie sieci VLAN i budowanie mniejszej liczby drzew rozpinających (po 1 drzewie dla każdej grupy) to:; PVSTP (Per VLAN Spanning Tree Protocol); MSTP (Multiple Spanning Tree Protocol); RSTP (Rapid Spanning Tree Protocol); SPB (Shortest Path Bridging); B; 
[#157] Nazwa procesu przekazywania wiedzy o trasach pomiędzy różnymi protokołami rutowania dynamicznego IP w routerach IP, to:; redystrybucja; IP Route Spoofing; routing konwergentny; translacja adresów; A; 
[#158] Co określa standard IEEE 802.1Q?; wirtualne sieci LAN (VLAN) budowane w środowisku transportującym ramki; technologię tunelowania sieci VLAN o nazwie Q-in-Q; private VLAN nadbudowaną nad Ethernet; szyfrowanie ramek Ethernet; A; 
[#159] Protokół umożliwiający konwersję adresu IP zdalnej stacji na jej adres MAC w Ethernet, to:; SLIP (Serial Line Internet Protocol); ARP (Address Resolution Protocol); MLD (Multicast Listener Discovery); DHCP (Dynamic Host Configuration Protocol); B; 
[#160] Dwie podwarstwy definiowane w ramach warstwy drugiej modelu ISO-OSI to odpowiednio:; FDDI i CDDI; LAN i WAN; LP (Link Pulse) i PHY (Physical); LLC (Logical Link Control) i MAC (Media Access Control); D; 
[#161] Rodzaj obszaru (area) w domenie OSPF (Open Shortest Path First) nie otrzymującego żadnych informacji o zewnętrznych (external) trasach rutowania OSPF, to:; backbone; internal; stub area; NSSA; C; 
[#163] Dwa rodzaje obszarów (area) w protokole routingu dynamicznego IS-IS (Intermediate System to Intermediate System), to:; intra-area i inter-area; stub i backbone; LAN i WAN; Autonomous System i Internal System; A; 
[#164] Dla uniknięcia błędów uwarunkowanych czasowo, maksymalna liczba procesów, które mogą znajdować się wewnątrz sekcji krytycznej, wynosi:; 8; 1; 0; 16; B; 
[#165] Inicjalna wartość semafora uogólnionego implementującego sekcję krytyczną wynosi:; 0; 1; -1; dowolna liczba dodatnia; B; 
[#166] Proces transferowania danych, które mają być docelowo wyprowadzone na urządzenie peryferyjne, do przestrzeni pamięci pomocniczej i transferowanie ich na to urządzenie w dogodniejszym czasie nosi nazwę:; spooling; virtualization; caching; throttling; A; 
[#167] Centralny Procesor, po otrzymaniu informacji o przerwaniu z urządzenia wejścia/wyjścia:; zatrzymuje się na określony okres czasu; przekazuje sterowanie do systemu obsługi przerwań po zakończeniu wykonywania bieżącej instrukcji; natychmiast przerywa bieżące zadanie; ignoruje przerwanie, jeśli jest w trybie użytkownika; B; 
[#168] Który z problemów rozwiązuje zaproponowany przez Dijkstrę algorytm bankiera:; wzajemnego wykluczania (mutual exclusion); wzajemnego zakleszczenia (deadlock exclusion); unikania zakleszczenia (deadlock avoidance); unikania wykluczania (exclusion avoidance); C; 
[#169] System operacyjny jest:; zbiorem składników sprzętowych (hardware routines); zbiorem driverów obsługujących urządzenia wejścia-wyjścia (input-output devices); zbiorem składników programowych (software routines); interfejsem użytkownika graficznego; C; 
[#171] Buforowanie plików realizowane jest w celu:; zwiększenia wydajności dostępu do pamięci pomocniczej; wspomagania obsługi przerwań; zwiększenia wydajności procesora; wyrównania różnic prędkości przesyłania danych między różnymi urządzeniami; D; 
[#177] Generalizacja:; organizuje obiekty w hierarchię uogólniania/uszczegóławiania; organizuje klasy w hierarchię całości/części; znajduje swoje odzwierciedlenie w mechanizmie dziedziczenia interfejsów; znajduje swoje odzwierciedlenie w mechanizmie dziedziczenia implementacji; C; 
[#180] Relacja realizacji wskazuje, że; obiekt klasy może być argumentem wywołania usługi innej klasy; klasa dostarcza implementacji usług interfejsu; klasa realizuje usługi delegowane z innej klasy; klasa wykorzystuje usługi interfejsu; B; 
[#183] Niech N będzie niedeterministycznym automatem skończonym posiadającym ^^n^^ stanów, oraz niech M będzie minimalnym deterministycznym automatem skończonym rozpoznającym ten sam język, posiadającym ^^m^^ stanów. Wtedy:; ^^m \leq n^^; ^^m \leq 2^n^^; ^^n \leq m^^; M posiada dokładnie jeden stan akceptujący; B; 
[#186] Odnośnie lematu o pompowaniu dla języków regularnych prawdziwe są następujące stwierdzenia:; lemat służy pokazaniu, że określone języki są regularne; schemat postępowania jest następujący: skoro język posiada pewne własności regularności, to jest regularny; lemat służy do dowodzenia, że dany język nie jest językiem regularnym; lemat służy do dowodzenia, że dany język jest językiem regularnym; C; 
[#187] Jeżeli ^^r^^ oraz ^^s^^ są wyrażeniami regularnymi dla języków odpowiednio ^^R^^ oraz ^^S^^, to ^^(r + s)^^, ^^rs^^ oraz ^^r*^^ są wyrażeniami regularnymi reprezentującymi odpowiednio zbiory:; ^^R \cup S^^, ^^R \times S^^, ^^R^{+}^^; ^^R \cup S^^, ^^R \times S^^, ^^R*^^; ^^R \cup S^^, ^^RS^^, ^^R*^^; ^^R \cup S^^, ^^RS^^, ^^R^{+}^^; C; 
[#188] Mamy języki ^^L1 = \{ a^{2^n}, n > 0 \}^^ oraz ^^L2 = \{ a^{2n}, n > 0 \}^^. Które z tych języków są regularne?; ^^L1^^ - nie, ^^L2^^ - nie; ^^L1^^ - tak, ^^L2^^ - nie; ^^L1^^ - nie, ^^L2^^ - tak; ^^L1^^ - tak, ^^L2^^ - tak; C; 
[#189] Eliminując niejednoznaczność gramatyki poprzez konwersję do innej gramatyki musimy zachować bez zmian:; drzewo wyprowadzenia oryginalnej gramatyki dla każdego jednoznacznego słowa wejściowego; wyprowadzenia oryginalnej gramatyki dla każdego słowa wejściowego; zbiór słów generowanych przez oryginalną gramatykę; drzewo wyprowadzenia oryginalnej gramatyki dla każdego słowa wejściowego; C; 
[#193] W odniesieniu do pracy parserów klasy LR(k) i funkcji action prawdziwe są stwierdzenia:; funkcja action przyjmuje wartości ze zbioru {shift, reduce, goto, accept, error}; na stosie trzymane są prefiksy i sufiksy form zdaniowych, co do których jest nadzieja na ich wykorzystanie; funkcja action przyjmuje wartości ze zbioru {shift, reduce, accept, error}; na stosie trzymane są prefiksy wszystkich form zdaniowych; C; 
[#196] Sekcja krytyczna procesu jest to:; część procesu, w której wykorzystywany jest zasób dzielony; część procesu, w której wykonywana jest komunikacja z użytkownikiem; część procesu, w której wykonywana jest nieskończona pętla; część procesu, w której deklarowane są lokalne zmienne; A; 
[#197] Wzajemnym wykluczaniem nazywamy problem współzawodnictwa procesów o zasób, który:; musi zostać zainicjalizowany przez jeden z procesów; jest zmienną przechowywaną w rejestrach procesora; jednocześnie może być wykorzystywany tylko przez jeden z nich; może być wykorzystywany tylko przez z góry określony czas; C; 
[#208] Wartość 5/16 ma postać w systemie binarnym:; 0.0101; 0.1011; 0.1010; 0.0011; A; 
[#209] Wartość 1/10 ma postać w systemie binarnym:; 0.1010; 0.0(0011); 0.(1010); 0.0(1010); B; 
[#210] Język formalny jest:; sposobem zapisu algorytmów opartym na blokach operacyjnych; sposobem zapisu algorytmów opartym na pseudokodzie; zbiorem reguł gramatycznych dla języka naturalnego; metodą wizualizacji struktury danych; B; 
[#211] Syntaktyka języka programowania opisuje:; znaczenie instrukcji w języku; formalnie poprawne programy; budowę instrukcji w języku; działanie poprawnego programu; C; 
[#212] Semantyka języka programowania opisuje:; znaczenie instrukcji w języku; formalnie poprawne programy; budowę instrukcji w języku; działanie poprawnego programu; A; 
[#213] Nawiasy <> w notacji EBNF oznaczają:; opcjonalne wystąpienie elementu; symbol terminalny; symbol nieterminalny; wielokrotne występowanie elementu; C; 
[#214] Kodem ASCII możemy zakodować:; dowolny znak z zakresu 0-128; dowolny znak z zakresu 0-255; dowolny znak z zakresu 32-255; dowolny znak z zakresu 0-127; D; 
[#217] Dana jest następująca reprezentacja liczb zmiennopozycyjnych: mantysa zajmuje 22 bity, w tym bit znaku, cecha zajmuje 10 bitów, w tym bit znaku. Cecha i mantysa zapisywane są w kodzie U2. Przecinek leży na lewo od mantysy (mantysa jest ułamkiem [1/2...1)). Jaka jest największa możliwa liczba w tym systemie?; 10^10; (1-2^(-21)) * 2^(2^9-1); (1-2^(-22)) * 2^(2^10-1); 2^1023; B; 
[#218] Jaka jest minimalna liczba bitów, aby reprezentować liczby zmiennopozycyjne z zakresu -106...106 z dokładnością do 2 miejsc znaczących?; 8 bitów; 12 bitów; 4 bity; 14 bitów; B; 
[#221] Liczby stałopozycyjne w komputerze są reprezentowane w kodzie uzupełnień do 2. Dla jakich wartości funkcja abs(x) będzie obliczona prawidłowo?; tylko dla liczb ujemnych; tylko dla liczb nieujemnych; dla wszystkich liczb typu integer; wszystkich poza najmniejszą liczbą w reprezentacji; D; 
[#222] Zmienna typu wskaźnik zajmuje 4 bajty. Ile pamięci można zaadresować takim wskaźnikiem?; 64 kilobajty; 4 gigabajty; 2 megabajty; 6 gigabajtów; B; 
[#224] Jeżeli w programie następuje odwołanie poza obszar tablicy:; zawsze sygnalizowany jest błąd wykonania; nie jest sygnalizowany błąd, jeżeli pamięć jest zaalokowana; program jest automatycznie zatrzymywany; kompilator generuje ostrzeżenie; B; 
[#225] Translacja analizuje symbole:; od lewej do prawej strony; od prawej do lewej strony; jednocześnie z obu stron; w losowej kolejności; A; 
[#226] Jaki wynik da następujące wyrażenie napisane w ONP: 2 3 4 5 + * +?; 25; 29; 31; 17; B; 
[#228] Jakie byłyby konsekwencje znalezienia wielomianowego deterministycznego algorytmu dla problemu NP-zupełnego?; stanowiłoby to dowód, że P = NP; oznaczałoby to, że P =/= NP; nie miałoby to żadnych konsekwencji dla teorii złożoności obliczeniowej; każdy problem algorytmiczny można byłoby rozwiązać w czasie wielomianowym; A; 
[#230] Co można powiedzieć o podproblemach problemu ^^\pi^^, wiedząc, że ^^\pi \notin P^^?; żaden jego podproblem nie należy do P; każdy jego podproblem należy do klasy P; pojęcie podproblemu nie jest zdefiniowane; istnieje taki jego podproblem, który należy do P; D; 
[#231] Która z poniższych złożoności czasowych jest wykładnicza:; ^^O(n^100)^^; ^^O(n^{1/n!})^^; ^^O((\log{10})^n)^^; ^^O(n!)^^; C; 
[#233] W teorii złożoności obliczeniowej wszystkie problemy decyzyjne, które w wielomianowym czasie rozwiązuje niedeterministyczna maszyna Turinga, tworzą pewną klasę problemów. Jak brzmi jej nazwa?; klasa NP; klasa P; klasa coNP; klasa RE; A; 